@namespace DcimIngester.Rules
@classname Parser

program<ProgramNode>
 = #{ state["Indentation"] = 0; } b:block {new ProgramNode(b)} 

block<BlockNode>
  = INDENTATION head:rule EOL<2> tail:block { new BlockNode(head).Concat(tail)}
  / INDENTATION line:rule { new BlockNode(line) }

rule<RuleNode> 
  = (c:condition _ '"' p:path '"' EOL b:block) {new RuleNode(c,p,b,new EmptyNode())}
  / (c:condition _ '"' p:path '"' EOL INDENT b:block UNDENT) {new RuleNode(c,p,new EmptyNode(),b)} 
  / (c:condition _ '"' p:path '"') {new RuleNode(c,p,new EmptyNode(),new EmptyNode())}

condition<SyntaxNode> 
  = (l:conditionType '=' '"' r:conditionString '"' ) {new EqualsNode(l,r)}
  / (l:conditionType '!=' '"' r:conditionString '"' ) {new NotNode(l,r)}
  / (l:conditionType '>' '"' r:conditionString '"' ) {new GreaterThanNode(l,r)}
  / (l:conditionType '<' '"' r:conditionString '"' ) {new LessThanNode(l,r)}
  / (l:conditionType '<=' '"' r:conditionString '"' ) {new GreaterOrEqualsNode(l,r)}
  / (l:conditionType '>=' '"' r:conditionString '"' ) {new LessOrEqualsNode(l,r)}
  / 'any' {new AnyNode()}

conditionString<StringNode> = s:("" [^\\/:*?"<>|.]+) {new StringNode(s)}

stringInterpolation<SyntaxNode> = "{" c:conditionType "}" {c} 

path<PathNode> 
  = head:pathComponent tail:path {new PathNode(head).Concat(tail)}
  / part:pathComponent {new PathNode(part)}

pathComponent<SyntaxNode> 
  = pathString
  / stringInterpolation

pathString<StringNode> = s:("" [^\\:*?"<>|}{]+) {new StringNode(s)}

conditionType<SyntaxNode>
    = "extension" {new ExtensionNode()}
    / "camera"  {new CameraNode()}

_ = [\t ]+
EOL = '\n' / '\r\n'

INDENTATION
  = spaces:" "* &{ spaces.Count == state["Indentation"] }

INDENT
  = #{ state["Indentation"] += 4; }

UNDENT
  = #{ state["Indentation"] -= 4; }