@namespace DcimIngester.Rules
@classname Parser

program<ProgramNode>
 = #{ state["Indentation"] = 0; } b:block {new ProgramNode(b)} 

block<BlockNode>
  = INDENTATION head:rule EOL<2> tail:block { new BlockNode(head).Concat(tail)}
  / INDENTATION line:rule { new BlockNode(line) }

rule<RuleNode> 
  = (c:condition _ p:path EOL b:block) {new RuleNode(c,p,b,new EmptyNode())}
  / (c:condition _ p:path EOL INDENT b:block UNDENT) {new RuleNode(c,p,new EmptyNode(),b)} 
  / (c:condition _ p:path ) {new RuleNode(c,p,new EmptyNode(),new EmptyNode())}

condition<SyntaxNode> 
  = (l:conditionType '=' '"' r:("" [^\\/:*?"<>|.]+) '"' ) {new EqualsNode(l,r)}
  / 'any' {new AnyNode()}

path<PathNode> = '"' s:("" [^\\:*?"<>|]+) '"' {new PathNode(s)}

conditionType<SyntaxNode>
    = "extension" {new ExtensionNode()}
    / "camera"  {new CameraNode()}

_ = [\t ]+
EOL = '\n' / '\r\n'

INDENTATION
  = spaces:" "* &{ spaces.Count == state["Indentation"] }

INDENT
  = #{ state["Indentation"] += 4; }

UNDENT
  = #{ state["Indentation"] -= 4; }